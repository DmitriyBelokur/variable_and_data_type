# Переменные и базовые типы языка
## Переменные
Программы чаще всего манипулируют данными, например расчет формул, или отображения каких либо данных на экране и т.д. Т.е. для выполнения задач над этими данными, нам необходимая некая сущность чтобы управлять этими данными, например хранить результат вычесление одной формулы и использовать как часть входных параметров для другой формулы. И этой сущностью являеться переменная. Т.е. переменная это ячейка в памяти которая предназначенна для манипуляции даными в этой ячейке, т.е. хранить или записывать данные в ячейке. Другими словами переменная это уникальный идентификатор через который мы можем сослаться на участок памяти, с которой связана переменная. Переменная это просто имя предназначеное для удобности чтения кода, но компилятор воспринимает ее как адресс ячейки памяти. Переменная должна удовлетворять правилам именования идентификаторов, которые описаны в предыдущем разделе.
Например представте вы пишете персонажа к игре, и персонаж в какойто момент времени имеет позицию на карте, соответственно персонаж может перемещаться по карте, и нам необходимо сохранять координаты персонажа в переменной, т.е. сохранять их в памяти, и если нам необходимо перерисовать карту или уточнить где находиться персонаж мы можем обратиться к переменой и взять у нее текущие координаты персонажа.
Необходимо обьязательно запомнить что назначение читаемого имени идентификатору, играет ключевую роль при написании приложения(это упрощаят для читающего ваш код восприятия что делает эта переменная и какая ее цель).
Для того что бы использовать переменную ее неободимо обьявить(создать), стоит сказать что в отличии от динамических языков(например JavaScript) язык С++ являеться строготипизированным языком. Это означает что вы должны при создании переменной указать ее тип, и в процессе работы с переменной вы не можете менять ее тип. Для создания переменной указывают тип переменной и ее имя(идентификатор), другими словам выделяем память под эту переменную. ТУт стоит сказать что иногд компиляторы могут и не выделить память под эту переменную, если она в коде не используеться. Ниже синтаксис обьявление переменной:
```cpp
// синтаксис обьявления переменной
тип_данных имя_переменной;
```
Важно что ниже мы будем рассматривать переменные, не уточняя об области памяти где они будут создаваться.

## Типы данных
Как было сказано выше переменная это ячейка памяти, к которой мы обращаемся указывая имя переменной. И все операции чтения или записи это просто оперрации с байтами(т.к. самая маленькая единица памяти это байт). Поэтому тип данных при указании переменой это на самом деле узакание компилятору сколько байт выделить под эту ячейку памяти, т.е. сколько байт надо прочитать и сколько записать. С++ присутствут большое количество типов. Различают два вида типов встроенные и пользовательские. В этом разделе мы расмотрим только встроенные типы(фундаментальные типы), а вот пользовтельсткие мы будем рассматривать в друих разделах.
https://ru.cppreference.com/w/cpp/language/types
https://en.cppreference.com/w/cpp/language/types
https://en.cppreference.com/w/cpp/header/cstdint

### Целочисленные типы
Наверное являються одним из часто используемых типов данных. В основном в языке С++ выделяют 3 основных целочисленных типа int, short, long. С появлением С++11 появились также новые типы (фиксированные)int8_t, int16_t и т.д. Целочисленый тип предназначен, как можно сделать вывод с названия, для хранения целых данных без дробной частью. Целый тип характерезиуеться размером в битах, до С++11 размер был 16, 32, 64 бит соответсвенно, но в С++11 появились  так называемые типы с фиксированым размером. Связано это с тем что например тип int на разных моделях данных(архитектурах\платформах) может быть разной, может быть 16, а может и 32, и это иногда вызывало проблемы когда программа портировалась с одной архитектуры на другую, так и появились типы с фиксированым размером, для того чтобы гарантировать фиксацию размера переменной. Что такое битность типа, это говорит то что, в зависимости от количества бит которое может предстаить тип и связано какое максимальное число можно прочитать и записать в память. Целочисленные типы разделяют на знаковые и безнаковые, разница заключаеться только в диапазоне минимального и максимального хранимого значения в переменной. По умолчанию все целые типы есть знаковые.
```cpp
int a; // на самом деле это signed int ~32 bit, т.е. ключевое слово signed можно опускать
short b; // ~16 bit
// signed short int b; это идентичная обьявление как и выше, только можно опускать ключевые слова signed и int
long c; // ~32-64 bit
// signed long int c; это идентичная обьявление как и выше, только можно опускать ключевые слова signed и int
unsigned int d; // это беззнаковое целое ~32, как видно чтобы создать беззнаковое значение нужно указать unsigned
unsigned short e; // беззнаковое короткое целое ~16
// unsigned short int e; это идентичная обьявление как и выше, только можно опустить ключевое слово int
unsigned long f; // беззнаковое длиное целое ~32-64, 
// unsigned long  int f; это идентичная обьявление как и выше, только можно опустить ключевое слово int
long long g; // long long int ~64 начиная с C++11
```
Как видно с выше перечисленных примеров `int` иногда опускают при указании короткого целого или длиного целого, также все целые типы по умолчанию знаковые (можно не указывать ключевое слово `signed`). Но если мы хотим обьявить переменную беззнакового типа надо явно укзать ключевое слово `unsigend`
А что произойдет если попробывать записать число размер которого больше чем можно записать в переменную(т.е. попытаться записать больше бит чем может содержать переменная) , произойдет так называемое переполнение, причем число после переполнения зависит от знакости типа.
```cpp
// если размер short ~ 16 бит, т.е. возможное максимальное беззнаковое 
// число которое можно записать в эту переменную есть 65535
// в нашем примере мы пытаемся записать большее число, соответсвенно переменная х будет содержать другое число
// произойдет так называемая переполнение
unsigned short x = 65536;

// если у нас знаковоя переменная то ее максимальный диапазон есть
// от -32768 to 32767 (65535 пополам, часть на знаковую, а вторую часть на беззнаковую)
// в нашем примере мы пытаемся записать большее число, соответсвенно переменная y будет содержать другое число
// произойдет так называемая переполнение
short y = 32768;
```
Стандарт строго гарантирует что:
sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long).
Целочисленные литералы по умолчанию представленны типом int если литерал может поместиться в этом типе, иначе типом long(говорять происходит продвижение типа)
Также стоит отметить что в С++(из за наследия С) есть специальные макросы/константы для представления максимального и минимального допустимого хранимого значения в переменной
http://www.cplusplus.com/reference/climits/
Но я бы рекомендовал использовать std::numeric_limits со стандартной библиотеки, который предлагает огромный функционал для представленого типа(например, как знак, так минимальное или максимальное значение). Вообщем рекомендую использовать только его.
https://en.cppreference.com/w/cpp/types/numeric_limits

### Символьный тип
Симвльный тип имеет нескольк особенностей. Во-первых он представлен для хранения символов, а во-вторых его используют как целочисленный тип для хранения небольших целых чисел. Давайте последовательно со всем этим разбермся.
Символьный тип в базовой форме имеет название `char`, размер его на разных архитектурах может быть разным, но в основном он представлен 1 байтом. Также как и целые тип `char` может быть знаковым и беззнаковым(что кажеться неким сумашедствием). Разница только в диапазоне допустимых чисел. Для знаковых это от -128 до 127, для беззнаковых от 0 до 255.
Часто в программах можно видеть что тип char используется для хранения целых чисел, например в циклах, это связано с тем что этот тип представлен только одним байтом (т.е. для небольшого диапазона числел), но это редкость. В основном(и желательно только) тип char используют для хранения символов, т.е. представляет диапазон ASCII таблицы (которая содержит спец символы, знаки и английский алфавит), т.е. вмещаеться в диапазон от 0..127. В этой таблице (ASCII), иногда ее называют таблица кодировки, представлян числовой диапазон в котором закодированы символы, например числом 89, в таблице представлен(закодирован) символ `A`. По умолчанию тип `char` представляет однобайтовую кодировку ASCII, но есть и другие таблицы кодировки,так называемые расширенные, Windows-1251(поддерживает кирилицу), CP866(поддерживает кирилицу), в которых таблица представленна 256ю значениями, являються устаревшими.
Все эти кодировки это так называемые 8 битовые кодировки. Большое распостранения получили так называемые кодировка Unicode, т.е. поддерживает все символы мира, упоминают такие кодировки(способы представления символов) как UTF-8(ASCII), UTF-16, UTF-32. Для этого в С++ есть следующие типы, т.к. называемые широкие строки `wchar_t`(2х байтовые), и более специализированные char16_t, char32_t начиная с С++11 стандарта.
Вообщем стандартом оговорено следующее:
1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long).
Маленький пример
```cpp
// присваиваем символьной переменной занчение 65 
char ch = 65;

// и выводим значение этой переменной на экран, но на экране мы увидем не значение 90, а символ А
// это связано с тем что в соотвтетсвии с таблицей кодировки 65 соответсвует символу A
std::cout << ch << std::endl;
```

## Целочисленные типы с фиксированными размером
Как было сказано выше в С++11 появились так называемые типы с фиксированный размером. Какая их цель? Проблема рассмотренных выше типов это то что размер их являеться архитектурно зависимым, т.е. на разных платформах их размер(максимальное допустимое занчение) может быть разным. И это вызывало много проблем, если мы полагаемся на размер этого типа, например 32 бита, но если наша программа переноситься(т.е. будет выполняться) на другой архитектуре, где максимальный размер типа меньше, то это может призвести к нежелаемым последствиям. Для решения такого рода проблем как раз и появились типы с фиксированным размером.
```cpp
uint8_t, uint16_t, uint32_t, и т.д.
int8_t, int16_t, int32_t, и т.д.   
```
Количество их достаточно большое, для полного списка нужно обратиться к справочному руководству языка.
Как видно символ `u` вначале говорит что тип у нас беззнаковый, цифры в типе говорят о количестве битов которое представляет этот тип.
## Алиас(псеводонимы) типов данных. Тип данных size_t. Ключевое слово typedef и using.
Давайте представим что мы обьявляем переменную которая предназначенная для хранения времени.
```cpp
unsigned long long start;
unsigned long long end;

```
Если присмотреться то код правильный, но логически сложно понять что эти переменные предназначенны для хранения времени(если это явно не написать коментарии возле этих переменных, или писать в имени каждый раз time). Хотелось бы иметь тип данных который бы говорил что мы обьявляем переменную для хранения времени. Но к сожалению такого типа нет, да он и ненужен, если посмотреть выше строку то тип уже есть, но он как мы поняли не информативный. Для этих целей в С++ есть такое понятие как псевдоним типа, идея его в том что мы существующему типа даем другое имя. И если мы обьявляем переменную с этим типом, то мы подразумеваем то тип псевдонимом которого он являеться. До С++11 использовали только ключевое слово `typedef` в С++11 добавили новое ключевое слово `using`
```cpp
 using my_time_t = unsigned long long; // начиная с С++11
// typedef unsigned long long my_time_t; // до С++11

 my_time_t start;
 my_time_t end;
```
Как видно все достаточно просто, я рекомендую использовать более новый подход с применением ключевого слова `using`.
В языке довольно много псевдонимнных типов данных. Один из часто используемых есть тип `size_t`, и тип данных `time_t`.
### Пустой тип void
Тип `void` не являеться как типом таковым, он больше являеться индикатором. Его применение достаточно большое, и мы к нему будем возращаться довольно таки часто, по мере изучения языка С++.
### Логический тип
Логический тип предназначен для хранения значение только `false` или `true`, т.е для хранения логического результата выполнения опрерации или функции и т.д. Логический тип обьявляеться ключевым словом `bool`, размер типа в соответствии со стандартом не меньше 1 байта. Но из-за наследовательности(совместимости) языка С, язык С++ иммеет некие побочные эфекты с типом `bool`
Например.
```cpp
// правильное применения типа bool
bool bl1 = true;
bool bl2 = false;

// неправильное испольвания типа bool
bool bl3 = 6; // это равносильно присвоение true
bool bl4 = -10; // это равносильно присвоение true
bool bl5 = 0; // это равносильно присвоение false
```
Т.е. делая маленький вывод, то что любой целочисленный литерал может быть присвоен типу bool что будет эквивалентно присвоению литерала `true`, тогда как 0(единственый литерал) эквивалентен присвоению `false`.

### Типы с плавающей точкой
Вещественные типы призванны решать матиматические задачи или хранить например диагностические числа потребления энергии, и т.д. Т.е. в вещественных числах выделяют целую и дробную часть. Выделяют числа с одинарной точностью (float), двойной точностью (double), и четверной точностью (long double). Частый пример использования вещественных чисел можно встретить при работе с графикой, это координаты. Размеры вещественых типов варьируються от архитектуры к архитектуры, но стандарт гарантирует. Важно то что в отличии от целочисленных типов, для вещественных типов нет версии с фиксированным размером.
sizeof(float) <= sizeof(double) <= sizeof(long double)
Как видно из размера допустимых значений вещественных типов, они предназначенны для работы с точными значениями(мат формулами и т.д.).
Что означает точность? Ну представим что есть некая дробь 1/3, результат ее будет 0,333333... где дробная часть продолжается до бесконечности, но так как наша память не бесконечная, то для этого и применяться понятие точности для представление значищих цифр, а остальное теряеться. Т.е. число точности завист от размера представленого типа, например float — от 6 до 9 цифр (в основном 7), double — от 15 до 18 цифр (в основном 16), long double — 15, 18 или 33 (в зависимости от того, сколько байтов занимает тип). Важность, и в тоже время проблематичность работы с вещественными числами, являеться то что для них есть стандарт IEEE 754 (стандарт описывающий формат представления вещестенных чисел). Если попытаться присвоить число с большей точностью переменной которая может содержать число с меньшей точностью, то мы получим так называемое потерю в точности.
```cpp
float value {123.};
std::cout << value << std::endl;
double value1 {123.123};
std::cout << value1 << std::endl;

long double value2 {1.1231111};
std::cout << value2 << std::endl;

```
В отличии от целых чисел все вещественные числа знаковые. 
При работе с вещественными числами, надо быть очень акуратными, в часности поблемы округления, т.е. если число неможет быть представлено с указаной точностью то оно округляеться(с првилами матиматичекого округления). Т.е. вопрос в том как вещественные часла храняться в памяти, и это надо всегда помнить.
```cpp
double d_value {0.1};
// вывод количесва цифр в цисле
std::cout << std::setprecision(6); // default precision
std::cout << d_value << std::endl;
std::cout << std::setprecision(17); // posible double precision
std::cout << d_value << std::endl;
```

```cpp
// на экране мы увидим
0.1
0.10000000000000001
```
С выше перечисленого примера физическое хранения числа и того числа которое мы привыкли использовать в десятичной форме (как с числом 0.1), не совсем идентичное. Часто эти ошибки приводят в неправильном сравнении вещественных чисел, т.е. переменных с литералом, или перемееной установленной литералом с переменной которая была вычисленна с формулы (например 0.2 + 0.3).
Есть две спецефические константы это Inf и Nan
При работе с вещественными числами выделяют две категории специальных чисел: бесконечность Inf, и не число NaN.

Ниже приведенна ссылка на бинарное представление вещественных чисел
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB

```cpp
double div_by_zero = 5.0 / 0.0; // == INF, but we are divide 5.0 / -0.0 result will be == -INF
std::cout << div_by_zero << std::endl;
std::cout << (0.0 / 0.0) << std::endl;
```

```cpp
// на экране мы увидим
inf
-nan
```

## Объявление и инициализация переменных
В С++ перед тем как использовать переменную, как говорилось выше, ее нужно обьявить\созадть, но еще важно то что перед первым ее использованием нужно проинициализировать переменную неким значением. Ниже мы рассмотрим способы обьявления и инициализации переменной. Обьявление есть ввод в программу имени переменной. Т.е. выделить память под переменную указав количество байтов в качестве типа, и связать адресс выделенной памяти с переменной. При создании переменной происходит так званноя неявная инициализация, иногда говорят муссором, т.е. неисвестным значение, и при использовании такой переменной дальше в коде можно получить неопределенное поведение. Но при явной инициализации мы указываем конкретное значение переменной. В С++ есть множество подхода для обьявления и инициализации переменных, но мы пока расмотрим очень простые.

```cpp
  int int_value; // происходит обьявление переменной целого типа и неявная инициализация неизвестным значением
  std::cout << int_value << std::endl; // на экране может получить соовершенно неопределенное значение
  int value = 42; // происходит обьявление переменной целого типа и явная инициализация числом 42
  /*
  следующая инициализация такая же как и выше
  int value(42);
  int value = int(42);
  */
  std::cout << value << std::endl; // на экране мы увидем занчение 42
  // с появление С++11 повилось так называемая универсальная инициализация
  int value_uni{42};
  /*
   или избыточные
   int value_uni1 = {42};
   int value_uni2 = int{42};
  */
  std::cout << value_uni << std::endl; // на экране мы увидем занчение 42

  // инициализация нулем
  int zero = 0;
  /*
   следующая инициализация такая же как и выше
   int zero1 = int();
   но следующуе обьявление не есть ошибочное с точки зрения компилятора
   int zero(); // некоректное обьявление
   следующее обьявление также ошибочное
   int zero = (); // error
   int zero = {}; // compiled ok)
   int zero2{};
  */
  std::cout << zero << std::endl;

  // можно объвлять переменные в один ряд, только в том случае если у них общий тип
  int oneline_value1, oneline_value2 = 20, oneline_value3;
  std::cout  << oneline_value1 << " " << oneline_value2 << " " << oneline_value3 << std::endl;

  /*
  очень полезной функциональностью универсальныч инициализаций есть, уменьшение ошибки сужающего преобразования
  int reduce{1.5f}; // compilation error
  */
  int reduce = 1.5f; // compiles fine
  printf("reduce is = %d\n", reduce); // print 1
```

```
// получим следующий вывод
int_value is = 0
value is = 42
value_uni is = 42
zero is = 0
oneline_value1 is = 0, oneline_value2 is = 20, oneline_value1 is = 0
```

В новом стандарте появилось универсальная инициализация. Важность ее достаточна большая, она добаалена в стандарт для исправления большого количества ошибок, которые присущие старым подходам инициализации.
Расмотрим примеры
```cpp
// старый подход
// возможно если повезет получим предупреждения копилятора
short x1 = 32768;
short x2  = 1.25; // часто называют срезкой, т.е. x2 будет содержать только целую часть, т.е. 1
// новый подход
// ниже получим ошибки компиляции
short y1 {32768};
short y2 {1.25};

```
Если внимательно присмотреться. то можно заметить очень важную особенность, что при использовании старых подходов к инициализации возможно множество неожидаемых ошибок. Но с появлением в С++11 универсальной инициализации, количество ошибочных подходов с инициализацией уменьшилась. Т.е унифицированная инициализация это единиый сиснтаксис инициализации, котопый может, как минимум концептуально, использоваться везде и выражать все. Новая возможность фигурной инициализации заключается в том, что она запрещает неявное сужающие преобразование среди встроенных типов (narrowing conversion), т.е. если значение выражения в фигурном инициализаторе не может быть гарантировано выражено типом инициализируемого обьекта, код не компилируеться как видно с примера. Инициализация с применением круглых скобок не выполняет проверку сужающего преобразования, т.к. это может привести к неработоспособности много старого кода. Поэтому вывод так и напрашивается старайтесь больше использовать универсальную инициализацию.
## Оператор sizeof для получения размера типа
Мы до этого много говорили о размерах типов, и то что их размер может быть разным на разных платформах. Но как же узнать какой именно размер типа? Для этого в С++ есть специальный оператор `sizeof` который возращает размер в байтах выражение которое ему было переданно в круглых скобочках.
```cpp
int value {0};
std::cout << sizeof(value) << std::endl;

std::cout << sizeof(long) << std::endl;

std::cout << sizeof(double) << std::endl;

std::cout << sizeof(true) << std::endl;
```
### Автоматический вывод типов ключевое слово auto
До появляение стандарта С++11, при обьявлении переменной необходимо всегда было явно писать тип переменной. С появление стандарта С++11 появилось ключевое слово `auto` которое позволяет выводить типы с инициализируещего выражения
```cpp
  auto i = 10; // i type -> int
  auto f = 10.5; // f type -> double
  auto ch = 'h'; // ch type -> char
  auto var_uint(5u); // var_uint type -> unsigned int
```
Как видно с выше приведенных примеров нам не нужно больше писать тип возле переменной за нас это сделает компилятор. На самом деле это базовое применение ключевого слова `auto` оно имеет более широкое применение, и мы с ним будем больше знакомиться на протяжении курса.
Но рассмотрим плюсы применения `auto` перед привычным нам приемом указания явно типа. Это то что при обьявлении переменной с `auto` неяобходимо явно указывать начальное значение т.к. компилятор по этому выражению будет выводить тип переменной, т.е. пропадает проблема неинициализированных переменных.
Также в С++11 добавили паралельно с `auto` ключевое слово `decltype`. Смысл его тот же что и `auto`, но синтаксически немного отличаеться. 
```cpp
  int a = 10;
  decltype(i) new_int; // new_int такого же типа как и переменная int
  decltype(10) deduction_type; // deduction_type будет типа int, т.к. тип целочисленного литерала по умолчанию int
```

## Константы
Перед этим мы с вами рассматривали  литералы такие как целочисленные и т.д., что важно то что в стандарте не оговоренно как именно в памяти храняться литералы, но большинство склоняеться что они храняться непосредственно на регистрах(маленькая память на процессоре). Т.е. место хранения литералов это детали реализации, которые могут быть разными на разных архитектурах. Как мы знаем переменная это в общем ячейка в памяти которая имеет адресс. Тогда возникает вопрос, а что такое константа? Константа это то что не может быть изменнено на всей протяжении жизни переменной (в програмировани это можно назвать деталью реализации, т.к. есть механизмы позволяющие изменить значение переменной). В отличии от обычной переменной, значение которой мы можем менять многократно, с константой все иначе раз установленное значение не может меняться на протяжении жизни всей переменной. Часто можно услышать что с константой связано понятие readonly memory.
Немного разберемся с константой. В языке С++ константа применяеться во многих контекстах. Но в данном разделе мы рассмотрим константу как переменную. До этого мы рассматривали литералы, которые также являються константами, и вместо того чтобы по всей программе писать повторяющийся литерал(неважно какого он типа), ему можно дать имя, как имя переменной, и потом по имени ссылаться на него. Часто в программировании употребляют термин "magic number", когда делают код ревью колег, т.е. когда встречают в коде литерал, просят дать ему логическое имя что делает этот литерал, или зачем нужен (например вычисление формул, логическое описания коефициэнтов). В С++ есть как минимум три вида констант:
 - Это использования макроопределения #define (старый С стиль)
 - Использования ключевого слова const
 - Перечисления enum

### #define как именованная константа препроцессора
В далеком С небыло такого понятия как константа, но были литералы. Но литералы это источник больших логических ошибок в коде, т.к. например если один и тот же литерал встречаеться много раз в коде и необходимо изменить этот литерал, то иногда можно изменить не во всех местах, и получим так называемую ошибку логики программы(семантическую ошибку). Тогда програмисты начали давать имена этим литералам с помощью дериктивы препроцессора `#define`, т.е. если надо поменять значение литерала, то не надо бегать по всему коду, а можно поменять только в одном месте. Когда препроцессор орабатывает наш код на первом этапе он заменяет все макроопределения которые мы определяли для литералов, т.е. вставляет наши литералы на место где мы писали имена литералов.
```cpp
#define VAL1 20
#define VAL2 30.0

float summ = VAL1 + VAL2; // (20 + 30.0)

```
### Ключевое слово const
Проблемой макросов `#define` есть то что они не типобезопасны, т.е. макрос не имеет никакого типа, он просто вставлят значение в контексте и все. Это очень важно например при написании формул или присвоение значений. Важной особенностью обьявление констант с помощью ключевого слова `const`, то что это переменная которая имеет имя, тип, и много других особенностей которые мы будем рассматривать на протяжении курса. Отличием обьявление констант от обычных переменных, то что константу необходимо инициализировать при обьявлении, иначе будет ошибка компиляции. Инициализировать можно как литералом, так и значением другой переменной. Константа проинициализированна раз, неможет быть изменна на протяжении своей жизни, иначе мы получим ошибку компиляции.
```cpp
const int i = 20;

// i = 40; // compiler error, значение не может быть изменено

// const int k; // compiler error, константу необходимо проинициализировать
```
Простым словом константа это память только для чтения. Хотя стандартом не определено как должна храниться константа в памяти, стандартом оговорено что переменная обьявленна с помощью ключевого слова const не может быть измена на протяжении своей жизни.
### Константы с приминением ключевого слова enum
Перечисление enum мы подробно будет рассматривать в следующих раздел, а сдесь мы расмотрим ее как еще один способ обьявление констант.
```cpp
enum {
  FIRST, // равен 0
  SECOND, // равен 1
  THIRD // равен 2
};
. . .
enum {
  FORTY = 40,
  FORTY_ONE // равен 41
};

int value = FORTY;

std::cout << FORTY_ONE << THIRD;
```
Как видно перечисления похожи на макросы, на ключевое слово похожи. Такие перечесления могут быть только целочисленные. Попытка например написать один из перечислений вещественным литералом даст ошибку компиляции, т.е. перечисления неявно имеют тип int.
```cpp
enum {
  FLOAT = 1.1 // ошибка компиляции то что перечисления должны быть интегрального типа.
}
```
По умолчанию первый элемент перичесления имеет значение ноль, и следующие элементы перечисления соответственно плюс 1, т.е. FIRST инициализируеться нулем, SECOND инициализируеться 1 и т.д. Но можно задавать и явно инициализирующее значение как в примере с FORTY равное 40, и соответсвенно следующий элемент будет равен 41.