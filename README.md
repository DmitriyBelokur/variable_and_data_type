# Переменные и базовые типы языка
## Переменные
Программы чаще всего манипулируют данными, например расчет формул, или отображения каких либо данных на экране и т.д. Т.е. для выполнения задач над этими данными, нам необходимая некая сущность чтобы управлять этими данными, например хранить результат вычесление одной формулы и использовать как часть входных параметров для другой формулы. И этой сущностью являеться переменная. Т.е. переменная это ячейка в памяти которая предназначенна для манипуляции даными в этой ячейке, т.е. хранить или записывать данные в ячейке. Другими словами переменная это уникальное идентификатор через который мы можем сослаться на участок памяти, с которой связана переменная. Переменная это просто имя предназначеное для удобности чтения кода, при компиляции переменная это просто адресс ячейки памяти. Переменная должна удовлетворять правилам идентификаторов, которые описаны в предыдущем разделе.
Например представте вы пишете персонажа к игре, и персонаж в какойто момент времени имеет позицию на карте и персонаж может перемещаться по карте, и нам необходимо сохранять координаты персонажа в переменной, т.е. в памяти, и если нам необходимо перерисовать карту или уточнить где находиться персонаж мы можем обратиться к переменой и взять от туда текущие координаты персонажа.
Необходимо обьязательно запомнить что назначение правильного имени идентификатору, играет ключевую роль при написании приложения.
Для того что бы использовать переменную ее неободимо обьявить, для этого указывают тип переменной и ее имя, другими словами зарезервировать память под эту переменную. Почему зарезервировать, т.к. если переменная не будет использована в программе компилятор может удалить эту переменную и обьектного файла.
```cpp
// синтаксис обьявления переменной
тип_данных имя_переменной;
```
В отличие от литералов под которые не выделяется место в памяти(исключением является строковые литералы), переменные обычно храняться в стеке или куче, реже в памяти сегмента кода. При этом выделяют три вида переменных локальные, статические и динамические. В этом разделе будут в основном расматриваться локальные переменные которые будут храниться на стеке.
Если в двух словах стек это структура данных работающая по принципу LIFO(последний вошел, первый вышел), т.е. предоставляет автоматическую работу с памятью. Т.е. перемення попавшая на стек имеет предустановленное правило жизни, и вы никак не можете на это повлиять. Стек более подробно будет рссмотрен при работе с поматью.

## Типы данных
Как было сказано выше переменная это просто именновая ячейка памяти. И все операции чтения или записи это просто оперрации с байтами(т.к. самая маленькая единица памяти это байт). Поэтому тип данных при указании переменой это на самом деле узакание компилятору сколько байт выделить под эту ячейку памяти, т.е. сколько байт надо прочитать и сколько записать. С++ присутствут большое количество типов. Различают два вида типов встроенные и пользовательские. В этом разделе мы расмотрем только встроенные типы(фундаментальные типы), а вот пользовтельсткие мы будем рассматривать в друих разделах.
https://ru.cppreference.com/w/cpp/language/types
https://en.cppreference.com/w/cpp/language/types
https://en.cppreference.com/w/cpp/header/cstdint

### Целочисленные типы
В основном в языке С++ выделяют 3 основных целочисленных типа int, short, long. С появлением С++11 появились также новые типы int8_t, int16_t и т.д. Целочисленый тип предназначен, как можно сделать вывод с названия, для хранения целых данных без дробной частью. Целый тип характерезиуеться размером в битах, до С++11 размер был 16, 32, 64 бит соответсвенно, с появлением С++ появились  так называемые типы с фиксированым размером. Связано это с тем что например тип int на разных моделях данных(архитектурах) может быть разной, может быть 16, а может и 32, и это иногда вызывало проблемы когда программа портировалась с одной архитектуры на другую, так и появились типы с фиксированым размером, для того чтобы гарантировать фиксацию размера переменной. В зависимости от количества бит которое представляет тип и связано какое число можно считать и записать в память. Целочисленные типы выделяют как знаковые так и безнаковые, разница заключаеться только диапазоне минимального и максимального хранимого значения в переменной.
```cpp
int a; // на самом деле это signed int ~32 bit
short b; // signed short int ~16
long c; // signed long int ~32-64
unsigned int d; // это беззнаковое целое ~32
unsigned short e; // беззнаковое короткое целое ~16
unsigned long f; // беззнаковое длиное целое ~32-64
long long g; // long long int ~64 начиная с C++11
```
Как видно с выше перечисленных примеров `int` иногда опускаю при указании короткого целого или длиного целого, также все целые типы по умолчанию знаковые.
А что произойдет если попробывать записать цисло которое привышает количество бит, произойдет так называемое переполнение, причем число после переполнения зависит от знакости типа. Что бы понять переполнение надо перевести число в двоичный формат и посмотреть сколько битов необходимо для представления этого числа, и если количество битов больше максимального числа, то крайние левы биты будут отброшены.
```cpp
unsigned short x = 65535;
x = x + 1; // вданом случае произойдет переполнение и x возможно будет равен 0
/*
возможеная работа
65535 в доичной форме это 1111 1111 1111 1111 занимает 16 бит
65536 1 0000 0000 0000 0000 и занимает 17 бит
и соответсвенно главныйлевый бит теряеться, а остальные 16 остаються
*/
```
Стандарт строго гарантирует что:
sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long).
Целочисленные литералы по умолчанию представленны типом int если литерал может поместиться в этом типе, иначе типом long
Также стоит отметить что в С++ есть специальные макросы для представления максимального и минимального допустимого хранимого значения в переменной
http://www.cplusplus.com/reference/climits/
Но я бы рекомендовал использовать так называемый клас std::numeric_limits, которое предлагает огромный функционал для представленого типа(например, как знак, так минимальное или максимальное значение)
https://en.cppreference.com/w/cpp/types/numeric_limits